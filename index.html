<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–û—Ñ–∏—Å–Ω–∞—è –ö—É—Ö–Ω—è —Å –¢–µ–∫—Å—Ç—É—Ä–æ–π –ü–æ–ª–∞ –∏ –®—Ç—Ä–∏—Ö–∫–æ–¥–æ–º</title>
  <style>
    body { margin: 0; background: #e8f0ff; overflow: hidden; position: relative;}
    #tip {
      position: absolute; left: 12px; top: 12px;
      background: #fff;
      padding: 7px 16px;
      border-radius: 8px;
      box-shadow: 0 2px 8px #3452b3a0;
      font-family: sans-serif;
      z-index: 10;
    }
    #blocker {
      position: fixed; inset: 0;
      background: #0009;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      z-index: 99;
      cursor: pointer;
    }
    #crosshair {
      position: fixed;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      width: 6px; height: 6px;
      pointer-events: none;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 0 3.5px #4448;
      z-index: 50;
    }
    #barcodeSvg {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: #222;
      border-radius: 6px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 100;
      padding: 10px;
    }
    #phone {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 300px;
      height: 500px;
      background: #222;
      border-radius: 25px;
      border: 8px solid #333;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      z-index: 1000;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      color: white;
      font-family: Arial, sans-serif;
    }
    #phone-header {
      padding: 10px 15px;
      background: #111;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }
    #phone-screen {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      background: #1a1a1a;
    }
    #phone-footer {
      padding: 10px;
      background: #111;
      display: flex;
      justify-content: space-around;
    }
    #phone-footer button {
      background: #333;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 14px;
    }
    #phone-footer button:hover {
      background: #444;
    }
    #scan-mode {
      text-align: center;
      padding: 20px;
    }
    #scanner-animation {
      width: 200px;
      height: 100px;
      margin: 20px auto;
      background: linear-gradient(to bottom, transparent 50%, rgba(255,255,255,0.1) 50%);
      background-size: 100% 200%;
      animation: scan 2s infinite;
      border: 2px solid #444;
      border-radius: 8px;
    }
    @keyframes scan {
      0% { background-position: 0 0; }
      100% { background-position: 0 200%; }
    }
    #scanned-items {
      margin-top: 20px;
      text-align: left;
    }
    #scanned-items div {
      padding: 8px;
      margin: 5px 0;
      background: #2a2a2a;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
    }
    #cart-items {
      margin: 15px 0;
    }
    #cart-items div {
      padding: 10px;
      margin: 8px 0;
      background: #2a2a2a;
      border-radius: 5px;
      display: flex;
      justify-content: space-between;
    }
    #cart-items button {
      background: #ff4444;
      color: white;
      border: none;
      padding: 3px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    #pay-button {
      width: 100%;
      padding: 12px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 15px;
    }
    #payment-mode {
      text-align: center;
      padding: 40px 20px;
    }
    #payment-mode h2 {
      color: #4CAF50;
      margin-bottom: 20px;
    }
  </style>
</head>
</head>
<body>
  <div id="blocker">–ö–ª–∏–∫–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å</div>
  <div id="crosshair"></div>
  <svg id="barcodeSvg"></svg>
  <!-- –¢–µ–ª–µ—Ñ–æ–Ω –≤ –ø—Ä–∞–≤–æ–º –Ω–∏–∂–Ω–µ–º —É–≥–ª—É -->
  <div id="phone">
    <div id="phone-header">
      <div id="phone-time">12:34</div>
      <div id="phone-battery">üîã 98%</div>
    </div>
    <div id="phone-screen">
      <div id="scan-mode">
        <h3>–°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–≤–∞—Ä</h3>
        <div id="scanner-animation"></div>
        <div id="scanned-items"></div>
      </div>
      <div id="cart-mode" style="display: none;">
        <h3>–í–∞—à–∞ –∫–æ—Ä–∑–∏–Ω–∞</h3>
        <div id="cart-items"></div>
        <div id="cart-total">–ò—Ç–æ–≥–æ: 0 —Ä—É–±.</div>
        <button id="pay-button">–û–ø–ª–∞—Ç–∏—Ç—å</button>
      </div>
      <div id="payment-mode" style="display: none;">
        <h2>–û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!</h2>
        <p>–ü—Ä–∏—è—Ç–Ω–æ–≥–æ –∞–ø–ø–µ—Ç–∏—Ç–∞!</p>
      </div>
    </div>
    <div id="phone-footer">
      <button id="cart-toggle">üõí –ö–æ—Ä–∑–∏–Ω–∞</button>
      <button id="scan-toggle">üì∑ –°–∫–∞–Ω–µ—Ä</button>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>

  <script>
    // === SCENE & CAMERA SETUP ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf6fafd);
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 8);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // === LOAD TEXTURES ===
    const loader = new THREE.TextureLoader();
    const floorTexture = loader.load('textures/wood_floor.jpg');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(8,8);
    const floorMat = new THREE.MeshPhongMaterial({ map: floorTexture });
    const floorGeom = new THREE.PlaneGeometry(50,50);
    const floor = new THREE.Mesh(floorGeom, floorMat);
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    const wallTextureUrl = 'textures/wall_texture.png';
    let wallMaterial;
    const wallTex = loader.load(wallTextureUrl);
    wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
    wallTex.repeat.set(3,1);
    wallMaterial = new THREE.MeshPhongMaterial({ map: wallTex });
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 6), wallMaterial);
    backWall.position.set(0, 3, -9); scene.add(backWall);
    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(18, 6), wallMaterial);
    leftWall.position.set(-10, 3, 0); leftWall.rotation.y = Math.PI/2; scene.add(leftWall);
    const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(18, 6), wallMaterial);
    rightWall.position.set(10, 3, 0); rightWall.rotation.y = -Math.PI/2; scene.add(rightWall);
    const ceilingTexture = loader.load('textures/Ceiling.png');
    ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
    ceilingTexture.repeat.set(7, 7);
    const ceilMat = new THREE.MeshPhongMaterial({ map: ceilingTexture });
    const ceil = new THREE.Mesh(new THREE.PlaneGeometry(28, 22), ceilMat);
    ceil.rotation.x = Math.PI/2; ceil.position.y = 6; scene.add(ceil);

    // === WINDOWS ===
    function addWindow(x,y,z) {
      const frameMat = new THREE.MeshPhongMaterial({color:0xd0e0fb});
      const frame = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.2, 0.18), frameMat);
      frame.position.set(x,y,z+0.01); scene.add(frame);
      const glassMat = new THREE.ShaderMaterial({
        uniforms: {baseColor: {value: new THREE.Color('#badcff')}},
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform vec3 baseColor;
          void main(){
            float l = 0.8 + 0.3 * sin(vUv.x*8.0 + vUv.y*10.0);
            float edge = smoothstep(0.85,1.0,vUv.y) + smoothstep(0.05,0.0,vUv.y);
            gl_FragColor = vec4(baseColor*l + edge*vec3(0.93,0.98,1.0)*0.5, 0.64 + edge*0.18);
          }
        `,
        transparent:true
      });
      const glass = new THREE.Mesh(new THREE.BoxGeometry(1.7,1.7,0.14), glassMat);
      glass.position.set(x,y,z+0.021); scene.add(glass);
    }
    addWindow(-4, 3.6, -8.97);
    addWindow(4, 2.15, -8.97);

    // === FRIDGE ===
    const fridgeMaterial = new THREE.MeshPhongMaterial({color:0xdbe5f3});
    const fridgeWalls = [
      new THREE.Mesh(new THREE.BoxGeometry(2,4,0.1), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(0.1,4,2), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(0.1,4,2), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(2,0.14,2), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(2,0.18,2), fridgeMaterial)
    ];
    fridgeWalls[0].position.set(0,2,-0.95);
    fridgeWalls[1].position.set(-0.95,2,0);
    fridgeWalls[2].position.set(0.95,2,0);
    fridgeWalls[3].position.set(0,4,0);
    fridgeWalls[4].position.set(0,0,0);
    fridgeWalls.forEach(m=>scene.add(m));
    const shelfMat = new THREE.MeshPhongMaterial({color:0xbfc9d6});
    [3.04, 2.07, 1.10].forEach(y=>{
      const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.85,0.09,1.78), shelfMat);
      shelf.position.set(0,y,0);
      scene.add(shelf);
    });
    const doorGroup = new THREE.Group();
    scene.add(doorGroup);
    const doorMat = new THREE.MeshPhongMaterial({color:0xe3eaf5});
    const door = new THREE.Mesh(new THREE.BoxGeometry(2,4,0.13), doorMat);
    door.position.set(0,2,1.03);
    doorGroup.add(door);
    const handleMat = new THREE.MeshPhongMaterial({color:0x7a7a7a});
    const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.10,0.10,0.7,16), handleMat);
    handle.rotation.x = Math.PI/2;
    handle.position.set(0.95,2.2,1.29);
    doorGroup.add(handle);

    // === KITCHEN COUNTER ===
    function createKitchenCounter() {
      // Counter materials
      const counterTopMat = new THREE.MeshPhongMaterial({color: 0x5a5a5a});
      const counterBodyMat = new THREE.MeshPhongMaterial({color: 0x8a8a8a});
      const sinkMat = new THREE.MeshPhongMaterial({color: 0xcccccc, shininess: 50});
      const faucetMat = new THREE.MeshPhongMaterial({color: 0xaaaaaa, shininess: 80});

      // Create counter group
      const counterGroup = new THREE.Group();
      scene.add(counterGroup);

      // Counter base (cabinets)
      const counterBase = new THREE.Mesh(
        new THREE.BoxGeometry(6, 0.8, 0.6),
        counterBodyMat
      );
      counterBase.position.set(-3, 0.4, -8);
      counterGroup.add(counterBase);

      // Counter top
      const counterTop = new THREE.Mesh(
        new THREE.BoxGeometry(6.2, 0.05, 0.7),
        counterTopMat
      );
      counterTop.position.set(-3, 0.9, -8);
      counterGroup.add(counterTop);

      // Sink
      const sink = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.08, 0.5),
        sinkMat
      );
      sink.position.set(-3, 0.92, -7.5);
      counterGroup.add(sink);

      // Faucet
      const faucetBase = new THREE.Mesh(
        new THREE.CylinderGeometry(0.02, 0.02, 0.05, 16),
        faucetMat
      );
      faucetBase.position.set(-3, 0.98, -7.5);
      counterGroup.add(faucetBase);

      const faucetNeck = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.015, 0.15, 16),
        faucetMat
      );
      faucetNeck.position.set(-3, 1.08, -7.5);
      faucetNeck.rotation.x = -0.3;
      counterGroup.add(faucetNeck);

      const faucetSpout = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.015, 0.015),
        faucetMat
      );
      faucetSpout.position.set(-3, 1.05, -7.4);
      counterGroup.add(faucetSpout);

      // Add some cabinet doors
      for (let i = 0; i < 3; i++) {
        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.3, 0.02),
          counterBodyMat
        );
        door.position.set(-3.8 + i * 1.3, 0.5, -7.9);
        counterGroup.add(door);

        const handle = new THREE.Mesh(
          new THREE.BoxGeometry(0.02, 0.05, 0.01),
          faucetMat
        );
        handle.position.set(-3.8 + i * 1.3, 0.5, -7.85);
        counterGroup.add(handle);
      }
    }

    // Create the kitchen counter
    createKitchenCounter();

    // === ADDITIONAL KITCHEN CABINETS ===
    function createKitchenCabinets() {
      const cabinetMat = new THREE.MeshPhongMaterial({color: 0x9a9a9a});
      const doorMat = new THREE.MeshPhongMaterial({color: 0xaaaaaa});
      const handleMat = new THREE.MeshPhongMaterial({color: 0x555555});

      // Upper cabinets (wall-mounted)
      for (let i = 0; i < 4; i++) {
        const upperCabinet = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.4, 0.35),
          cabinetMat
        );
        upperCabinet.position.set(-4.2 + i * 1.5, 2.2, -7.65);
        scene.add(upperCabinet);

        // Cabinet doors
        const doorLeft = new THREE.Mesh(
          new THREE.BoxGeometry(0.58, 0.35, 0.02),
          doorMat
        );
        doorLeft.position.set(-4.5 + i * 1.5, 2.2, -7.5);
        scene.add(doorLeft);

        const doorRight = new THREE.Mesh(
          new THREE.BoxGeometry(0.58, 0.35, 0.02),
          doorMat
        );
        doorRight.position.set(-3.9 + i * 1.5, 2.2, -7.5);
        scene.add(doorRight);

        // Handles
        const handleLeft = new THREE.Mesh(
          new THREE.BoxGeometry(0.02, 0.02, 0.05),
          handleMat
        );
        handleLeft.position.set(-4.4 + i * 1.5, 2.2, -7.45);
        scene.add(handleLeft);

        const handleRight = new THREE.Mesh(
          new THREE.BoxGeometry(0.02, 0.02, 0.05),
          handleMat
        );
        handleRight.position.set(-4.0 + i * 1.5, 2.2, -7.45);
        scene.add(handleRight);
      }

      // Lower cabinets (under counter)
      for (let i = 0; i < 3; i++) {
        const lowerCabinet = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.3, 0.55),
          cabinetMat
        );
        lowerCabinet.position.set(-4.5 + i * 1.7, 0.2, -7.65);
        scene.add(lowerCabinet);

        // Cabinet door
        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.45, 0.25, 0.02),
          doorMat
        );
        door.position.set(-4.5 + i * 1.7, 0.2, -7.4);
        scene.add(door);

        // Handle
        const handle = new THREE.Mesh(
          new THREE.BoxGeometry(0.02, 0.05, 0.02),
          handleMat
        );
        handle.position.set(-4.5 + i * 1.7, 0.2, -7.35);
        scene.add(handle);
      }

      // Corner cabinet
      const cornerCabinet = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.8, 0.8),
        cabinetMat
      );
      cornerCabinet.position.set(-6.2, 0.4, -6.5);
      scene.add(cornerCabinet);

      // Tall storage cabinet
      const tallCabinet = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, 2.0, 0.5),
        cabinetMat
      );
      tallCabinet.position.set(-1.8, 1.0, -7.65);
      scene.add(tallCabinet);

      // Tall cabinet doors
      const tallDoor1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.23, 1.9, 0.02),
        doorMat
      );
      tallDoor1.position.set(-1.95, 1.0, -7.4);
      scene.add(tallDoor1);

      const tallDoor2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.23, 1.9, 0.02),
        doorMat
      );
      tallDoor2.position.set(-1.65, 1.0, -7.4);
      scene.add(tallDoor2);

      // Handles for tall cabinet
      const tallHandle1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.02, 0.05),
        handleMat
      );
      tallHandle1.position.set(-1.95, 1.0, -7.35);
      scene.add(tallHandle1);

      const tallHandle2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.02, 0.05),
        handleMat
      );
      tallHandle2.position.set(-1.65, 1.0, -7.35);
      scene.add(tallHandle2);
    }

    // Create kitchen cabinets
    createKitchenCabinets();

    // === BOXES WITH BARCODE DATA ===
    const boxBarcodes = [
      "123456789012", "987654321098", "135790246813", "246801357924", "112233445566"
    ];
    const boxes = [];
    function addBox(x,y,z,color,index) {
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.39, 0.30, 0.54),
        new THREE.MeshPhongMaterial({color: color})
      );
      mesh.position.set(x,y,z);
      mesh.userData.barcode = boxBarcodes[index];
      scene.add(mesh);
      boxes.push(mesh);
    }
    addBox(-0.5, 3.32, 0.36, 0xfaad6b, 0);
    addBox(0.52, 3.1, -0.49, 0x52bbc7, 1);
    addBox(-0.6, 2.32, -0.38, 0xc8a6f7, 2);
    addBox(0.42, 2.38, 0.43, 0xaed947, 3);
    addBox(0, 1.3, 0.05, 0xfa709a, 4);

    // === CHAIRS ===
    function addChair(x, z, rot) {
      // Materials
      const blackMat = new THREE.MeshPhongMaterial({color: 0x222222});
      const grayMat = new THREE.MeshPhongMaterial({color: 0x555555});
      const seatMat = new THREE.MeshPhongMaterial({color: 0x333333});
      const metalMat = new THREE.MeshPhongMaterial({color: 0x777777, shininess: 30});

      // Create a group for the chair
      const chairGroup = new THREE.Group();
      chairGroup.position.set(x, 0, z);
      chairGroup.rotation.y = rot;
      scene.add(chairGroup);

      // Seat
      const seatGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.5);
      const seat = new THREE.Mesh(seatGeometry, seatMat);
      seat.position.y = 0.4;
      chairGroup.add(seat);

      // Backrest
      const backrestGeometry = new THREE.BoxGeometry(0.45, 0.4, 0.05);
      const backrest = new THREE.Mesh(backrestGeometry, seatMat);
      backrest.position.set(0, 0.65, -0.2);
      chairGroup.add(backrest);

      // Armrests
      const armrestGeometry = new THREE.BoxGeometry(0.15, 0.03, 0.3);
      const leftArmrest = new THREE.Mesh(armrestGeometry, grayMat);
      leftArmrest.position.set(-0.22, 0.45, 0.1);
      leftArmrest.rotation.z = -0.1;
      chairGroup.add(leftArmrest);

      const rightArmrest = new THREE.Mesh(armrestGeometry, grayMat);
      rightArmrest.position.set(0.22, 0.45, 0.1);
      rightArmrest.rotation.z = 0.1;
      chairGroup.add(rightArmrest);

      // Base and wheels
      const baseGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.05, 16);
      const wheelGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);

      // Central column
      const columnGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.35, 16);
      const column = new THREE.Mesh(columnGeometry, metalMat);
      column.position.y = 0.2;
      chairGroup.add(column);

      // Five wheels
      const wheelPositions = [
        {x: 0.18, z: 0.18},
        {x: -0.18, z: 0.18},
        {x: 0.18, z: -0.18},
        {x: -0.18, z: -0.18},
        {x: 0, z: -0.22}
      ];

      for (const pos of wheelPositions) {
        const wheelBase = new THREE.Mesh(baseGeometry, blackMat);
        wheelBase.position.set(pos.x, 0.02, pos.z);
        chairGroup.add(wheelBase);

        const wheel = new THREE.Mesh(wheelGeometry, grayMat);
        wheel.position.set(pos.x, 0.01, pos.z);
        chairGroup.add(wheel);
      }

      // Support arms for backrest
      const supportGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 16);
      const leftSupport = new THREE.Mesh(supportGeometry, metalMat);
      leftSupport.position.set(-0.2, 0.5, -0.18);
      leftSupport.rotation.x = 0.3;
      leftSupport.rotation.z = 0.2;
      chairGroup.add(leftSupport);

      const rightSupport = new THREE.Mesh(supportGeometry, metalMat);
      rightSupport.position.set(0.2, 0.5, -0.18);
      rightSupport.rotation.x = 0.3;
      rightSupport.rotation.z = -0.2;
      chairGroup.add(rightSupport);
    }

    // Add chairs to the scene
    addChair(-1.3, 1.0, Math.PI/9);
    addChair(1.3, 1.2, -Math.PI/7);
    addChair(-2.8, 2.6, Math.PI/12);
    addChair(2.2, 3.0, -Math.PI/12);

    // === LIGHTS ===
    scene.add(new THREE.PointLight(0xffffff, 1.1, 41).position.set(0, 8, 0));
    scene.add(new THREE.AmbientLight(0xcad6e4, 0.8));

    // –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤
    const products = {
      "123456789012": { name: "–°–∞–ª–∞—Ç –¶–µ–∑–∞—Ä—å", price: 350 },
      "987654321098": { name: "–ö—É—Ä–∏–Ω—ã–π —à–Ω–∏—Ü–µ–ª—å —Å –∫–∞—Ä—Ç–æ—à–∫–æ–π", price: 450 },
      "135790246813": { name: "–°—ç–Ω–¥–≤–∏—á —Å –∫—É—Ä–∏—Ü–µ–π", price: 250 },
      "246801357924": { name: "–¢–æ–º –Ø–º", price: 380 },
      "112233445566": { name: "–†–∞–º–µ–Ω", price: 420 }
    };

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ—Ä–∑–∏–Ω—ã
    let cart = [];

    // –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞ –≤ –∫–æ—Ä–∑–∏–Ω—É
    function addToCart(barcode) {
      const product = products[barcode];
      if (product) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π —Ç–æ–≤–∞—Ä –≤ –∫–æ—Ä–∑–∏–Ω–µ
        const existingItem = cart.find(item => item.barcode === barcode);
        if (existingItem) {
          existingItem.quantity += 1;
        } else {
          cart.push({ barcode, name: product.name, price: product.price, quantity: 1 });
        }
        updateCartUI();
        updateScanUI(barcode, product.name);
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
    function updateScanUI(barcode, name) {
      const scannedItems = document.getElementById('scanned-items');
      const itemElement = document.createElement('div');
      itemElement.innerHTML = `<span>${name}</span><span>+1</span>`;
      scannedItems.prepend(itemElement);

      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
      if (scannedItems.children.length > 5) {
        scannedItems.removeChild(scannedItems.lastChild);
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∫–æ—Ä–∑–∏–Ω—ã
    function updateCartUI() {
      const cartItemsElement = document.getElementById('cart-items');
      const cartTotalElement = document.getElementById('cart-total');

      // –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã
      cartItemsElement.innerHTML = '';

      // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–≤–∞—Ä—ã –∏–∑ –∫–æ—Ä–∑–∏–Ω—ã
      let total = 0;
      cart.forEach((item, index) => {
        const itemElement = document.createElement('div');
        const itemTotal = item.price * item.quantity;
        total += itemTotal;

        itemElement.innerHTML = `
          <span>${item.name} √ó${item.quantity}</span>
          <div>
            <span>${itemTotal} —Ä—É–±.</span>
            <button class="remove-item" data-index="${index}">‚ùå</button>
          </div>
        `;
        cartItemsElement.appendChild(itemElement);
      });

      // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Ç–æ–≥–æ–≤—É—é —Å—É–º–º—É
      cartTotalElement.textContent = `–ò—Ç–æ–≥–æ: ${total} —Ä—É–±.`;
    }

    // –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞ –∏–∑ –∫–æ—Ä–∑–∏–Ω—ã
    function removeFromCart(index) {
      cart.splice(index, 1);
      updateCartUI();
    }

    // –§—É–Ω–∫—Ü–∏—è –æ–ø–ª–∞—Ç—ã
    function processPayment() {
      // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –æ–ø–ª–∞—Ç—ã
      document.getElementById('scan-mode').style.display = 'none';
      document.getElementById('cart-mode').style.display = 'none';
      document.getElementById('payment-mode').style.display = 'block';

      // –ß–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—é
      setTimeout(() => {
        document.getElementById('payment-mode').style.display = 'none';
        document.getElementById('scan-mode').style.display = 'block';
        // –û—á–∏—â–∞–µ–º –∫–æ—Ä–∑–∏–Ω—É –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã
        cart = [];
        updateCartUI();
      }, 5000);
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞
    document.getElementById('cart-toggle').addEventListener('click', () => {
      document.getElementById('scan-mode').style.display = 'none';
      document.getElementById('cart-mode').style.display = 'block';
      document.getElementById('payment-mode').style.display = 'none';
    });

    document.getElementById('scan-toggle').addEventListener('click', () => {
      document.getElementById('scan-mode').style.display = 'block';
      document.getElementById('cart-mode').style.display = 'none';
      document.getElementById('payment-mode').style.display = 'none';
    });

    document.getElementById('pay-button').addEventListener('click', processPayment);

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–æ–≤ –∏–∑ –∫–æ—Ä–∑–∏–Ω—ã
    document.getElementById('cart-items').addEventListener('click', (e) => {
      if (e.target.classList.contains('remove-item')) {
        const index = parseInt(e.target.getAttribute('data-index'));
        removeFromCart(index);
      }
    });

    // === MOVEMENT CONTROLS ===
    let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let yaw = 0, pitch = 0;
    let onGround = true, yVel = 0;
    const jumpPower = 0.2, gravity = -0.008;
    const blocker = document.getElementById('blocker');
    blocker.addEventListener('click', () => { document.body.requestPointerLock(); });
    document.addEventListener('pointerlockchange', () => {
      blocker.style.display = (document.pointerLockElement === document.body) ? 'none' : 'flex';
    });
    document.addEventListener('mousemove', e => {
      if(document.pointerLockElement === document.body){
        yaw -= e.movementX*0.002;
        pitch -= e.movementY*0.002;
        pitch = Math.max(-Math.PI/2+0.2, Math.min(Math.PI/2-0.2, pitch));
      }
    });
    document.addEventListener('keydown', e => {
      if(e.code==='KeyW'||e.code==='ArrowUp') moveForward=true;
      if(e.code==='KeyS'||e.code==='ArrowDown') moveBackward=true;
      if(e.code==='KeyA'||e.code==='ArrowLeft') moveLeft=true;
      if(e.code==='KeyD'||e.code==='ArrowRight') moveRight=true;
      if(e.code==='Space' && onGround) { yVel = jumpPower; onGround=false; }
    });
    document.addEventListener('keyup', e => {
      if(e.code==='KeyW'||e.code==='ArrowUp') moveForward=false;
      if(e.code==='KeyS'||e.code==='ArrowDown') moveBackward=false;
      if(e.code==='KeyA'||e.code==='ArrowLeft') moveLeft=false;
      if(e.code==='KeyD'||e.code==='ArrowRight') moveRight=false;
    });

    // === DOOR AND PICKING BOXES WITH BARCODE DISPLAY ===
    const raycaster = new THREE.Raycaster();
    let doorOpen = false, doorAnim = 0;
    const barcodeSvg = document.getElementById('barcodeSvg');

    function nearFridgeHandle() {
      const hp = handle.getWorldPosition(new THREE.Vector3());
      const dx = camera.position.x - hp.x;
      const dz = camera.position.z - hp.z;
      const dy = camera.position.y - hp.y;
      return Math.sqrt(dx*dx + dz*dz) < 1.3 && Math.abs(dy) < 1.2;
    }

    window.addEventListener('mousedown', e => {
      if(document.pointerLockElement !== document.body) return;
      raycaster.setFromCamera({x:0, y:0}, camera);
      const intersects = raycaster.intersectObjects([handle, ...boxes]);
      if(intersects.length > 0){
        if (intersects[0].object === handle && nearFridgeHandle()) {
          doorOpen = !doorOpen;
        } else if (boxes.includes(intersects[0].object) && doorOpen) {
          const pickedBox = intersects[0].object;
          scene.remove(pickedBox);
          boxes.splice(boxes.indexOf(pickedBox), 1);
          const code = pickedBox.userData.barcode;
          JsBarcode(barcodeSvg, code, {
            format: "EAN13",
            lineColor: "#fff",
            background: "#222",
            width: 2,
            height: 60,
            displayValue: true,
            fontSize: 16,
            margin: 10
          });
          barcodeSvg.style.opacity = '1';
          barcodeSvg.style.pointerEvents = 'auto';
          setTimeout(() => {
            barcodeSvg.style.opacity = '0';
            barcodeSvg.style.pointerEvents = 'none';
          }, 4000);

          // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–≤–∞—Ä –≤ –∫–æ—Ä–∑–∏–Ω—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞
          addToCart(code);
        }
      }
    });

    // === COLLISION DETECTION FOR FRIDGE ===
    function blockCollision(px, pz) {
      const minX = -0.92, maxX = 0.92;
      const minZ = -0.90, maxZ = 0.80;
      if(px > minX && px < maxX && pz > minZ && pz < maxZ){
        if(pz < 0) return [px, minZ];
        else return [px, maxZ];
      }
      return [px, pz];
    }

    // === ANIMATION LOOP ===
    function animate() {
      camera.rotation.set(pitch, yaw, 0);
      direction.set(0,0,0);
      if(moveForward) direction.z -= 1;
      if(moveBackward) direction.z += 1;
      if(moveLeft) direction.x -= 1;
      if(moveRight) direction.x += 1;
      direction.normalize();
      direction.applyEuler(camera.rotation);
      velocity.copy(direction).multiplyScalar(0.10);

      let newX = camera.position.x + velocity.x;
      let newZ = camera.position.z + velocity.z;
      [newX, newZ] = blockCollision(newX, newZ);
      camera.position.x = newX;
      camera.position.z = newZ;
      camera.position.y += yVel;
      yVel += gravity;
      if(camera.position.y < 1.6){
        camera.position.y = 1.6;
        yVel = 0;
        onGround = true;
      }
      if(doorOpen && doorAnim < 1) doorAnim += 0.05;
      if(!doorOpen && doorAnim > 0) doorAnim -= 0.05;
      doorGroup.rotation.y = -Math.PI/2 * doorAnim;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // === HANDLE RESIZE ===
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
