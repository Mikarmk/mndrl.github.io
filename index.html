<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Офисная Кухня с Текстурой Пола</title>
  <style>
    body { margin: 0; background: #e8f0ff; overflow: hidden;}
    #tip {
      position: absolute; left: 12px; top: 12px;
      background: #fff;
      padding: 7px 16px;
      border-radius: 8px;
      box-shadow: 0 2px 8px #3452b3a0;
      font-family: sans-serif;
      z-index:10;
    }
    #blocker {
      position:fixed; inset:0;
      background:#0009;
      color: #fff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1.5em;
      z-index:99;
      cursor:pointer;
    }
    #crosshair {
      position: fixed;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      width: 6px; height: 6px;
      pointer-events: none;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 0 3.5px #4448;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div id="tip">Теперь это кухня: пол с текстурой, стены с градиентом, окна с блеском</div>
  <div id="blocker">Кликните, чтобы начать</div>
  <div id="crosshair"></div>
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
    // === SCENE & CAMERA ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf6fafd);
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 8);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // === WOOD FLOOR TEXTURE ===
    const loader = new THREE.TextureLoader();
    const floorTexture = loader.load('https://media.istockphoto.com/id/641717800/ru/%D1%84%D0%BE%D1%82%D0%BE/%D0%B1%D0%B5%D1%81%D1%88%D0%BE%D0%B2%D0%BD%D0%B0%D1%8F-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8F%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D0%BB%D0%B0.jpg?s=612x612&w=0&k=20&c=S12JJhqkWFDHxJDWoUiJzUB7zVOnwnR3HeNDsJa3SUY=');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(8,8);
    const floorMat = new THREE.MeshPhongMaterial({
      map: floorTexture
    });
    const floorGeom = new THREE.PlaneGeometry(50, 50);
    const floor = new THREE.Mesh(floorGeom, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    scene.add(floor);

 // === WALLS: выбери текстура или градиент ===
 const wallTextureUrl = 'https://bigfoto.name/photo/uploads/posts/2023-10/1696314936_bigfoto-name-p-tekstura-besshovnaya-v-interere-72.jpg';

    let wallMaterial;
    if (wallTextureUrl) {
      const wallTex = loader.load(wallTextureUrl);
      wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
      wallTex.repeat.set(3,1);
      wallMaterial = new THREE.MeshPhongMaterial({ map: wallTex });
    } else {
      wallMaterial = new THREE.ShaderMaterial({
        uniforms: {
          topColor: {value: new THREE.Color('#f3f5fa')},
          bottomColor: {value: new THREE.Color('#e0e7f5')}
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform vec3 topColor;
          uniform vec3 bottomColor;
          void main(){
            vec3 color = mix(bottomColor, topColor, vUv.y);
            gl_FragColor = vec4(color, 1.0);
          }
        `
      });
    }
    // --- Задняя стена
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 6), wallMaterial);
    backWall.position.set(0, 3, -9);
    scene.add(backWall);
    // --- Левая
    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(18, 6), wallMaterial);
    leftWall.position.set(-10, 3, 0);
    leftWall.rotation.y = Math.PI/2;
    scene.add(leftWall);
    // --- Правая
    const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(18, 6), wallMaterial);
    rightWall.position.set(10, 3, 0);
    rightWall.rotation.y = -Math.PI/2;
    scene.add(rightWall);
    // --- Потолок
    const ceilMat = new THREE.MeshPhongMaterial({ color: 0xfafcff });
    const ceil = new THREE.Mesh(new THREE.PlaneGeometry(28, 22), ceilMat);
    ceil.rotation.x = Math.PI/2;
    ceil.position.y = 6;
    scene.add(ceil);

    // ============= ОКНА С ШЕЙДЕРОМ "СТЕКЛО" ===========
    function addWindow(x, y, z) {
      const frameMat = new THREE.MeshPhongMaterial({ color: 0xd0e0fb });
      // Рамка
      const frame = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.2, 0.18), frameMat);
      frame.position.set(x, y, z+0.01);
      scene.add(frame);
      // Стекло — шейдер
      const glassMat = new THREE.ShaderMaterial({
        uniforms: {
          baseColor: {value: new THREE.Color('#badcff')}
        },
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform vec3 baseColor;
          void main(){
            float l = 0.8+0.3*sin(vUv.x*8.0+vUv.y*10.0);
            float edge = smoothstep(0.85,1.0,vUv.y)+smoothstep(0.05,0.0,vUv.y);
            gl_FragColor = vec4(baseColor*l + edge*vec3(0.93,0.98,1.0)*0.5, 0.64+edge*0.18);
          }
        `,
        transparent: true
      });
      const glass = new THREE.Mesh(new THREE.BoxGeometry(1.7, 1.7, 0.14), glassMat);
      glass.position.set(x, y, z+0.021);
      scene.add(glass);
    }
    addWindow(-4, 3.6, -8.97);
    addWindow(4, 2.15, -8.97);

    // === ХОЛОДИЛЬНИК и КОРОБКИ ===
    const fridgeMaterial = new THREE.MeshPhongMaterial({ color: 0xdbe5f3 });
    const fridgeWalls = [
      new THREE.Mesh(new THREE.BoxGeometry(2, 4, 0.10), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(0.10, 4, 2), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(0.10, 4, 2), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(2, 0.14, 2), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(2, 0.18, 2), fridgeMaterial)
    ];
    fridgeWalls[0].position.set(0, 2, -0.95);
    fridgeWalls[1].position.set(-0.95, 2, 0);
    fridgeWalls[2].position.set(0.95, 2, 0);
    fridgeWalls[3].position.set(0, 4, 0);
    fridgeWalls[4].position.set(0, 0, 0);
    fridgeWalls.forEach(mesh => scene.add(mesh));
    const shelfMaterial = new THREE.MeshPhongMaterial({ color: 0xbfc9d6 });
    [3.04,2.07,1.10].forEach(y=>{
      const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.85, 0.09, 1.78), shelfMaterial);
      shelf.position.set(0, y, 0);
      scene.add(shelf);
    });
    const doorGroup = new THREE.Group();
    scene.add(doorGroup);
    const doorMat = new THREE.MeshPhongMaterial({ color: 0xe3eaf5 });
    const door = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 0.13), doorMat);
    door.position.set(0, 2, 1.03);
    doorGroup.add(door);
    doorGroup.position.set(0,0,0);
    const handleMat = new THREE.MeshPhongMaterial({color: 0x7a7a7a });
    const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.10, 0.10, 0.7, 16), handleMat);
    handle.rotation.x = Math.PI/2;
    handle.position.set(0.95, 2.2, 1.29);
    doorGroup.add(handle);
    const boxes = [];
    function addBox(x, y, z, color) {
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.39, 0.30, 0.54),
        new THREE.MeshPhongMaterial({ color: color })
      );
      mesh.position.set(x, y, z);
      scene.add(mesh);
      boxes.push(mesh);
    }
    addBox(-0.5, 3.32, 0.36, 0xfaad6b);
    addBox(0.52, 3.1, -0.49, 0x52bbc7);
    addBox(-0.6, 2.32, -0.38, 0xc8a6f7);
    addBox(0.42, 2.38, 0.43, 0xaed947);
    addBox(0, 1.3, 0.05, 0xfa709a);

    // ====== СТУЛЬЯ ======
    function addChair(x, z, rot) {
      const mat1 = new THREE.MeshPhongMaterial({color:0xffffff});
      const mat2 = new THREE.MeshPhongMaterial({color:0x888888});
      const seat = new THREE.Mesh(new THREE.BoxGeometry(0.46,0.08,0.46), mat1);
      seat.position.set(x, 0.46, z);
      seat.rotation.y = rot; scene.add(seat);
      const back = new THREE.Mesh(new THREE.BoxGeometry(0.46,0.46,0.07), mat1);
      back.position.set(x, 0.69, z-0.19*Math.cos(rot) - 0.19*Math.sin(rot));
      back.rotation.y = rot; scene.add(back);
      for(const dx of [-0.16,0.16]) for(const dz of [-0.16,0.16]){
        const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.035,0.035,0.42,12), mat2);
        leg.position.set(x+dx*Math.cos(rot)-dz*Math.sin(rot), 0.22, z+dx*Math.sin(rot)+dz*Math.cos(rot));
        scene.add(leg);
      }
    }
    addChair(-1.3, 1.0, Math.PI/9);
    addChair( 1.3, 1.2, -Math.PI/7);
    addChair(-2.8, 2.6, Math.PI/12);
    addChair( 2.2, 3.0, -Math.PI/12);

    // ====== СВЕТ ==========
    scene.add(new THREE.PointLight(0xffffff, 1.1, 41).position.set(0, 8, 0));
    scene.add(new THREE.AmbientLight(0xcad6e4, 0.8));

    // === WALK PHYSICS/CONTROLS ===
    let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, canJump=false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let yaw = 0, pitch = 0;
    let onGround = true, yVel=0;
    const jumpPower = 0.2, gravity = -0.008;
    const blocker = document.getElementById('blocker');
    blocker.addEventListener('click', () => { document.body.requestPointerLock(); });
    document.addEventListener('pointerlockchange', ()=>{
      blocker.style.display = (document.pointerLockElement === document.body) ? 'none' : 'flex';
    });
    document.addEventListener('mousemove', e=>{
      if(document.pointerLockElement === document.body){
        yaw   -= e.movementX*0.002;
        pitch -= e.movementY*0.002;
        pitch = Math.max(-Math.PI/2 + 0.2, Math.min(Math.PI/2 - 0.2, pitch));
      }
    });
    document.addEventListener('keydown', e=>{
      if(e.code==='KeyW'||e.code==='ArrowUp') moveForward=true;
      if(e.code==='KeyS'||e.code==='ArrowDown') moveBackward=true;
      if(e.code==='KeyA'||e.code==='ArrowLeft') moveLeft=true;
      if(e.code==='KeyD'||e.code==='ArrowRight') moveRight=true;
      if(e.code==='Space' && onGround) { yVel = jumpPower; onGround=false; }
    });
    document.addEventListener('keyup', e=>{
      if(e.code==='KeyW'||e.code==='ArrowUp') moveForward=false;
      if(e.code==='KeyS'||e.code==='ArrowDown') moveBackward=false;
      if(e.code==='KeyA'||e.code==='ArrowLeft') moveLeft=false;
      if(e.code==='KeyD'||e.code==='ArrowRight') moveRight=false;
    });

    // === ОТКРЫТИЕ/ЗАКРЫТИЕ ДВЕРИ / ВЗЯТИЕ КОРОБОК ===
    const raycaster = new THREE.Raycaster();
    let doorOpen = false, doorAnim = 0;
    function nearFridgeHandle() {
      var dx = camera.position.x - handle.getWorldPosition(new THREE.Vector3()).x;
      var dz = camera.position.z - handle.getWorldPosition(new THREE.Vector3()).z;
      var dy = camera.position.y - handle.getWorldPosition(new THREE.Vector3()).y;
      return Math.sqrt(dx*dx + dz*dz) < 1.3 && Math.abs(dy)<1.2;
    }
    window.addEventListener('mousedown', e => {
      if(document.pointerLockElement !== document.body) return;
      raycaster.setFromCamera({ x:0, y:0 }, camera);
      const intersects = raycaster.intersectObjects([handle, ...boxes]);
      if (intersects.length > 0) {
        if (intersects[0].object === handle && nearFridgeHandle()) {
          doorOpen = !doorOpen; // переключение состояния
        } else if (boxes.includes(intersects[0].object) && doorOpen) {
          scene.remove(intersects[0].object);
        }
      }
    });

    function blockCollision(px, pz) {
      let fridgeMinX = -0.92, fridgeMaxX = 0.92;
      let fridgeMinZ = -0.90, fridgeMaxZ = 0.80;
      if (px > fridgeMinX && px < fridgeMaxX && pz > fridgeMinZ && pz < fridgeMaxZ) {
        if (pz < 0)      return [px, fridgeMinZ];
        else /*pz >=0*/  return [px, fridgeMaxZ];
      }
      return [px,pz];
    }

    function animate() {
      camera.rotation.set(pitch, yaw, 0);
      direction.set(0,0,0);
      if(moveForward) direction.z -= 1;
      if(moveBackward) direction.z += 1;
      if(moveLeft) direction.x -= 1;
      if(moveRight) direction.x += 1;
      direction.normalize();
      direction.applyEuler(camera.rotation);
      velocity.copy(direction).multiplyScalar(0.10);

      let newX = camera.position.x + velocity.x;
      let newZ = camera.position.z + velocity.z;
      [newX, newZ] = blockCollision(newX, newZ);
      camera.position.x = newX;
      camera.position.z = newZ;
      camera.position.y += yVel;
      yVel += gravity;
      if (camera.position.y < 1.6) { camera.position.y = 1.6; yVel=0; onGround=true; }
      if (doorOpen && doorAnim < 1) doorAnim += 0.05;
      if (!doorOpen && doorAnim > 0) doorAnim -= 0.05;
      doorGroup.rotation.y = -Math.PI/2*doorAnim;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
