<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Офисная Кухня с Текстурой Пола и Штрихкодом</title>
  <style>
    body { margin: 0; background: #e8f0ff; overflow: hidden;}
    #tip {
      position: absolute; left: 12px; top: 12px;
      background: #fff;
      padding: 7px 16px;
      border-radius: 8px;
      box-shadow: 0 2px 8px #3452b3a0;
      font-family: sans-serif;
      z-index: 10;
    }
    #blocker {
      position: fixed; inset: 0;
      background: #0009;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      z-index: 99;
      cursor: pointer;
    }
    #crosshair {
      position: fixed;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      width: 6px; height: 6px;
      pointer-events: none;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 0 3.5px #4448;
      z-index: 50;
    }
    #barcodeSvg {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: #222;
      border-radius: 6px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 100;
      padding: 10px;
    }
  </style>
</head>
<body>
  <div id="blocker">Кликните, чтобы начать</div>
  <div id="crosshair"></div>
  <svg id="barcodeSvg"></svg>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>

  <script>
    // === SCENE & CAMERA SETUP ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf6fafd);
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 8);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // === LOAD TEXTURES ===
    const loader = new THREE.TextureLoader();
    const floorTexture = loader.load('textures/wood_floor.jpg');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(8,8);
    const floorMat = new THREE.MeshPhongMaterial({ map: floorTexture });
    const floorGeom = new THREE.PlaneGeometry(50,50);
    const floor = new THREE.Mesh(floorGeom, floorMat);
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    const wallTextureUrl = 'textures/wall_texture.png';
    let wallMaterial;
    const wallTex = loader.load(wallTextureUrl);
    wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
    wallTex.repeat.set(3,1);
    wallMaterial = new THREE.MeshPhongMaterial({ map: wallTex });
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(20, 6), wallMaterial);
    backWall.position.set(0, 3, -9); scene.add(backWall);
    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(18, 6), wallMaterial);
    leftWall.position.set(-10, 3, 0); leftWall.rotation.y = Math.PI/2; scene.add(leftWall);
    const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(18, 6), wallMaterial);
    rightWall.position.set(10, 3, 0); rightWall.rotation.y = -Math.PI/2; scene.add(rightWall);
    const ceilingTexture = loader.load('textures/Ceiling.png');
    ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
    ceilingTexture.repeat.set(7, 7);
    const ceilMat = new THREE.MeshPhongMaterial({ map: ceilingTexture });
    const ceil = new THREE.Mesh(new THREE.PlaneGeometry(28, 22), ceilMat);
    ceil.rotation.x = Math.PI/2; ceil.position.y = 6; scene.add(ceil);

    // === WINDOWS ===
    function addWindow(x,y,z) {
      const frameMat = new THREE.MeshPhongMaterial({color:0xd0e0fb});
      const frame = new THREE.Mesh(new THREE.BoxGeometry(2.2, 2.2, 0.18), frameMat);
      frame.position.set(x,y,z+0.01); scene.add(frame);
      const glassMat = new THREE.ShaderMaterial({
        uniforms: {baseColor: {value: new THREE.Color('#badcff')}},
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform vec3 baseColor;
          void main(){
            float l = 0.8 + 0.3 * sin(vUv.x*8.0 + vUv.y*10.0);
            float edge = smoothstep(0.85,1.0,vUv.y) + smoothstep(0.05,0.0,vUv.y);
            gl_FragColor = vec4(baseColor*l + edge*vec3(0.93,0.98,1.0)*0.5, 0.64 + edge*0.18);
          }
        `,
        transparent:true
      });
      const glass = new THREE.Mesh(new THREE.BoxGeometry(1.7,1.7,0.14), glassMat);
      glass.position.set(x,y,z+0.021); scene.add(glass);
    }
    addWindow(-4, 3.6, -8.97);
    addWindow(4, 2.15, -8.97);

    // === FRIDGE ===
    const fridgeMaterial = new THREE.MeshPhongMaterial({color:0xdbe5f3});
    const fridgeWalls = [
      new THREE.Mesh(new THREE.BoxGeometry(2,4,0.1), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(0.1,4,2), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(0.1,4,2), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(2,0.14,2), fridgeMaterial),
      new THREE.Mesh(new THREE.BoxGeometry(2,0.18,2), fridgeMaterial)
    ];
    fridgeWalls[0].position.set(0,2,-0.95);
    fridgeWalls[1].position.set(-0.95,2,0);
    fridgeWalls[2].position.set(0.95,2,0);
    fridgeWalls[3].position.set(0,4,0);
    fridgeWalls[4].position.set(0,0,0);
    fridgeWalls.forEach(m=>scene.add(m));
    const shelfMat = new THREE.MeshPhongMaterial({color:0xbfc9d6});
    [3.04, 2.07, 1.10].forEach(y=>{
      const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.85,0.09,1.78), shelfMat);
      shelf.position.set(0,y,0);
      scene.add(shelf);
    });
    const doorGroup = new THREE.Group();
    scene.add(doorGroup);
    const doorMat = new THREE.MeshPhongMaterial({color:0xe3eaf5});
    const door = new THREE.Mesh(new THREE.BoxGeometry(2,4,0.13), doorMat);
    door.position.set(0,2,1.03);
    doorGroup.add(door);
    const handleMat = new THREE.MeshPhongMaterial({color:0x7a7a7a});
    const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.10,0.10,0.7,16), handleMat);
    handle.rotation.x = Math.PI/2;
    handle.position.set(0.95,2.2,1.29);
    doorGroup.add(handle);

    // === KITCHEN COUNTER ===
    function createKitchenCounter() {
      // Counter materials
      const counterTopMat = new THREE.MeshPhongMaterial({color: 0x5a5a5a});
      const counterBodyMat = new THREE.MeshPhongMaterial({color: 0x8a8a8a});
      const sinkMat = new THREE.MeshPhongMaterial({color: 0xcccccc, shininess: 50});
      const faucetMat = new THREE.MeshPhongMaterial({color: 0xaaaaaa, shininess: 80});

      // Create counter group
      const counterGroup = new THREE.Group();
      scene.add(counterGroup);

      // Counter base (cabinets)
      const counterBase = new THREE.Mesh(
        new THREE.BoxGeometry(6, 0.8, 0.6),
        counterBodyMat
      );
      counterBase.position.set(-3, 0.4, -8);
      counterGroup.add(counterBase);

      // Counter top
      const counterTop = new THREE.Mesh(
        new THREE.BoxGeometry(6.2, 0.05, 0.7),
        counterTopMat
      );
      counterTop.position.set(-3, 0.9, -8);
      counterGroup.add(counterTop);

      // Sink
      const sink = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.08, 0.5),
        sinkMat
      );
      sink.position.set(-3, 0.92, -7.5);
      counterGroup.add(sink);

      // Faucet
      const faucetBase = new THREE.Mesh(
        new THREE.CylinderGeometry(0.02, 0.02, 0.05, 16),
        faucetMat
      );
      faucetBase.position.set(-3, 0.98, -7.5);
      counterGroup.add(faucetBase);

      const faucetNeck = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.015, 0.15, 16),
        faucetMat
      );
      faucetNeck.position.set(-3, 1.08, -7.5);
      faucetNeck.rotation.x = -0.3;
      counterGroup.add(faucetNeck);

      const faucetSpout = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.015, 0.015),
        faucetMat
      );
      faucetSpout.position.set(-3, 1.05, -7.4);
      counterGroup.add(faucetSpout);

      // Add some cabinet doors
      for (let i = 0; i < 3; i++) {
        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.3, 0.02),
          counterBodyMat
        );
        door.position.set(-3.8 + i * 1.3, 0.5, -7.9);
        counterGroup.add(door);

        const handle = new THREE.Mesh(
          new THREE.BoxGeometry(0.02, 0.05, 0.01),
          faucetMat
        );
        handle.position.set(-3.8 + i * 1.3, 0.5, -7.85);
        counterGroup.add(handle);
      }
    }

    // Create the kitchen counter
    createKitchenCounter();

    // === ADDITIONAL KITCHEN CABINETS ===
    function createKitchenCabinets() {
      const cabinetMat = new THREE.MeshPhongMaterial({color: 0x9a9a9a});
      const doorMat = new THREE.MeshPhongMaterial({color: 0xaaaaaa});
      const handleMat = new THREE.MeshPhongMaterial({color: 0x555555});

      // Upper cabinets (wall-mounted)
      for (let i = 0; i < 4; i++) {
        const upperCabinet = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.4, 0.35),
          cabinetMat
        );
        upperCabinet.position.set(-4.2 + i * 1.5, 2.2, -7.65);
        scene.add(upperCabinet);

        // Cabinet doors
        const doorLeft = new THREE.Mesh(
          new THREE.BoxGeometry(0.58, 0.35, 0.02),
          doorMat
        );
        doorLeft.position.set(-4.5 + i * 1.5, 2.2, -7.5);
        scene.add(doorLeft);

        const doorRight = new THREE.Mesh(
          new THREE.BoxGeometry(0.58, 0.35, 0.02),
          doorMat
        );
        doorRight.position.set(-3.9 + i * 1.5, 2.2, -7.5);
        scene.add(doorRight);

        // Handles
        const handleLeft = new THREE.Mesh(
          new THREE.BoxGeometry(0.02, 0.02, 0.05),
          handleMat
        );
        handleLeft.position.set(-4.4 + i * 1.5, 2.2, -7.45);
        scene.add(handleLeft);

        const handleRight = new THREE.Mesh(
          new THREE.BoxGeometry(0.02, 0.02, 0.05),
          handleMat
        );
        handleRight.position.set(-4.0 + i * 1.5, 2.2, -7.45);
        scene.add(handleRight);
      }

      // Lower cabinets (under counter)
      for (let i = 0; i < 3; i++) {
        const lowerCabinet = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.3, 0.55),
          cabinetMat
        );
        lowerCabinet.position.set(-4.5 + i * 1.7, 0.2, -7.65);
        scene.add(lowerCabinet);

        // Cabinet door
        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.45, 0.25, 0.02),
          doorMat
        );
        door.position.set(-4.5 + i * 1.7, 0.2, -7.4);
        scene.add(door);

        // Handle
        const handle = new THREE.Mesh(
          new THREE.BoxGeometry(0.02, 0.05, 0.02),
          handleMat
        );
        handle.position.set(-4.5 + i * 1.7, 0.2, -7.35);
        scene.add(handle);
      }

      // Corner cabinet
      const cornerCabinet = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.8, 0.8),
        cabinetMat
      );
      cornerCabinet.position.set(-6.2, 0.4, -6.5);
      scene.add(cornerCabinet);

      // Tall storage cabinet
      const tallCabinet = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, 2.0, 0.5),
        cabinetMat
      );
      tallCabinet.position.set(-1.8, 1.0, -7.65);
      scene.add(tallCabinet);

      // Tall cabinet doors
      const tallDoor1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.23, 1.9, 0.02),
        doorMat
      );
      tallDoor1.position.set(-1.95, 1.0, -7.4);
      scene.add(tallDoor1);

      const tallDoor2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.23, 1.9, 0.02),
        doorMat
      );
      tallDoor2.position.set(-1.65, 1.0, -7.4);
      scene.add(tallDoor2);

      // Handles for tall cabinet
      const tallHandle1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.02, 0.05),
        handleMat
      );
      tallHandle1.position.set(-1.95, 1.0, -7.35);
      scene.add(tallHandle1);

      const tallHandle2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.02, 0.05),
        handleMat
      );
      tallHandle2.position.set(-1.65, 1.0, -7.35);
      scene.add(tallHandle2);
    }

    // Create kitchen cabinets
    createKitchenCabinets();

    // === BOXES WITH BARCODE DATA ===
    const boxBarcodes = [
      "123456789012", "987654321098", "135790246813", "246801357924", "112233445566"
    ];
    const boxes = [];
    function addBox(x,y,z,color,index) {
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.39, 0.30, 0.54),
        new THREE.MeshPhongMaterial({color: color})
      );
      mesh.position.set(x,y,z);
      mesh.userData.barcode = boxBarcodes[index];
      scene.add(mesh);
      boxes.push(mesh);
    }
    addBox(-0.5, 3.32, 0.36, 0xfaad6b, 0);
    addBox(0.52, 3.1, -0.49, 0x52bbc7, 1);
    addBox(-0.6, 2.32, -0.38, 0xc8a6f7, 2);
    addBox(0.42, 2.38, 0.43, 0xaed947, 3);
    addBox(0, 1.3, 0.05, 0xfa709a, 4);

    // === CHAIRS ===
    function addChair(x, z, rot) {
      // Materials
      const blackMat = new THREE.MeshPhongMaterial({color: 0x222222});
      const grayMat = new THREE.MeshPhongMaterial({color: 0x555555});
      const seatMat = new THREE.MeshPhongMaterial({color: 0x333333});
      const metalMat = new THREE.MeshPhongMaterial({color: 0x777777, shininess: 30});

      // Create a group for the chair
      const chairGroup = new THREE.Group();
      chairGroup.position.set(x, 0, z);
      chairGroup.rotation.y = rot;
      scene.add(chairGroup);

      // Seat
      const seatGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.5);
      const seat = new THREE.Mesh(seatGeometry, seatMat);
      seat.position.y = 0.4;
      chairGroup.add(seat);

      // Backrest
      const backrestGeometry = new THREE.BoxGeometry(0.45, 0.4, 0.05);
      const backrest = new THREE.Mesh(backrestGeometry, seatMat);
      backrest.position.set(0, 0.65, -0.2);
      chairGroup.add(backrest);

      // Armrests
      const armrestGeometry = new THREE.BoxGeometry(0.15, 0.03, 0.3);
      const leftArmrest = new THREE.Mesh(armrestGeometry, grayMat);
      leftArmrest.position.set(-0.22, 0.45, 0.1);
      leftArmrest.rotation.z = -0.1;
      chairGroup.add(leftArmrest);

      const rightArmrest = new THREE.Mesh(armrestGeometry, grayMat);
      rightArmrest.position.set(0.22, 0.45, 0.1);
      rightArmrest.rotation.z = 0.1;
      chairGroup.add(rightArmrest);

      // Base and wheels
      const baseGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.05, 16);
      const wheelGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);

      // Central column
      const columnGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.35, 16);
      const column = new THREE.Mesh(columnGeometry, metalMat);
      column.position.y = 0.2;
      chairGroup.add(column);

      // Five wheels
      const wheelPositions = [
        {x: 0.18, z: 0.18},
        {x: -0.18, z: 0.18},
        {x: 0.18, z: -0.18},
        {x: -0.18, z: -0.18},
        {x: 0, z: -0.22}
      ];

      for (const pos of wheelPositions) {
        const wheelBase = new THREE.Mesh(baseGeometry, blackMat);
        wheelBase.position.set(pos.x, 0.02, pos.z);
        chairGroup.add(wheelBase);

        const wheel = new THREE.Mesh(wheelGeometry, grayMat);
        wheel.position.set(pos.x, 0.01, pos.z);
        chairGroup.add(wheel);
      }

      // Support arms for backrest
      const supportGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 16);
      const leftSupport = new THREE.Mesh(supportGeometry, metalMat);
      leftSupport.position.set(-0.2, 0.5, -0.18);
      leftSupport.rotation.x = 0.3;
      leftSupport.rotation.z = 0.2;
      chairGroup.add(leftSupport);

      const rightSupport = new THREE.Mesh(supportGeometry, metalMat);
      rightSupport.position.set(0.2, 0.5, -0.18);
      rightSupport.rotation.x = 0.3;
      rightSupport.rotation.z = -0.2;
      chairGroup.add(rightSupport);
    }

    // Add chairs to the scene
    addChair(-1.3, 1.0, Math.PI/9);
    addChair(1.3, 1.2, -Math.PI/7);
    addChair(-2.8, 2.6, Math.PI/12);
    addChair(2.2, 3.0, -Math.PI/12);

    // === LIGHTS ===
    scene.add(new THREE.PointLight(0xffffff, 1.1, 41).position.set(0, 8, 0));
    scene.add(new THREE.AmbientLight(0xcad6e4, 0.8));

    // === MOVEMENT CONTROLS ===
    let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let yaw = 0, pitch = 0;
    let onGround = true, yVel = 0;
    const jumpPower = 0.2, gravity = -0.008;
    const blocker = document.getElementById('blocker');
    blocker.addEventListener('click', () => { document.body.requestPointerLock(); });
    document.addEventListener('pointerlockchange', () => {
      blocker.style.display = (document.pointerLockElement === document.body) ? 'none' : 'flex';
    });
    document.addEventListener('mousemove', e => {
      if(document.pointerLockElement === document.body){
        yaw -= e.movementX*0.002;
        pitch -= e.movementY*0.002;
        pitch = Math.max(-Math.PI/2+0.2, Math.min(Math.PI/2-0.2, pitch));
      }
    });
    document.addEventListener('keydown', e => {
      if(e.code==='KeyW'||e.code==='ArrowUp') moveForward=true;
      if(e.code==='KeyS'||e.code==='ArrowDown') moveBackward=true;
      if(e.code==='KeyA'||e.code==='ArrowLeft') moveLeft=true;
      if(e.code==='KeyD'||e.code==='ArrowRight') moveRight=true;
      if(e.code==='Space' && onGround) { yVel = jumpPower; onGround=false; }
    });
    document.addEventListener('keyup', e => {
      if(e.code==='KeyW'||e.code==='ArrowUp') moveForward=false;
      if(e.code==='KeyS'||e.code==='ArrowDown') moveBackward=false;
      if(e.code==='KeyA'||e.code==='ArrowLeft') moveLeft=false;
      if(e.code==='KeyD'||e.code==='ArrowRight') moveRight=false;
    });

    // === DOOR AND PICKING BOXES WITH BARCODE DISPLAY ===
    const raycaster = new THREE.Raycaster();
    let doorOpen = false, doorAnim = 0;
    const barcodeSvg = document.getElementById('barcodeSvg');

    function nearFridgeHandle() {
      const hp = handle.getWorldPosition(new THREE.Vector3());
      const dx = camera.position.x - hp.x;
      const dz = camera.position.z - hp.z;
      const dy = camera.position.y - hp.y;
      return Math.sqrt(dx*dx + dz*dz) < 1.3 && Math.abs(dy) < 1.2;
    }

    window.addEventListener('mousedown', e => {
      if(document.pointerLockElement !== document.body) return;
      raycaster.setFromCamera({x:0, y:0}, camera);
      const intersects = raycaster.intersectObjects([handle, ...boxes]);
      if(intersects.length > 0){
        if (intersects[0].object === handle && nearFridgeHandle()) {
          doorOpen = !doorOpen;
        } else if (boxes.includes(intersects[0].object) && doorOpen) {
          const pickedBox = intersects[0].object;
          scene.remove(pickedBox);
          boxes.splice(boxes.indexOf(pickedBox), 1);
          const code = pickedBox.userData.barcode;
          JsBarcode(barcodeSvg, code, {
            format: "EAN13",
            lineColor: "#fff",
            background: "#222",
            width: 2,
            height: 60,
            displayValue: true,
            fontSize: 16,
            margin: 10
          });
          barcodeSvg.style.opacity = '1';
          barcodeSvg.style.pointerEvents = 'auto';
          setTimeout(() => {
            barcodeSvg.style.opacity = '0';
            barcodeSvg.style.pointerEvents = 'none';
          }, 4000);
        }
      }
    });

    // === COLLISION DETECTION FOR FRIDGE ===
    function blockCollision(px, pz) {
      const minX = -0.92, maxX = 0.92;
      const minZ = -0.90, maxZ = 0.80;
      if(px > minX && px < maxX && pz > minZ && pz < maxZ){
        if(pz < 0) return [px, minZ];
        else return [px, maxZ];
      }
      return [px, pz];
    }

    // === ANIMATION LOOP ===
    function animate() {
      camera.rotation.set(pitch, yaw, 0);
      direction.set(0,0,0);
      if(moveForward) direction.z -= 1;
      if(moveBackward) direction.z += 1;
      if(moveLeft) direction.x -= 1;
      if(moveRight) direction.x += 1;
      direction.normalize();
      direction.applyEuler(camera.rotation);
      velocity.copy(direction).multiplyScalar(0.10);

      let newX = camera.position.x + velocity.x;
      let newZ = camera.position.z + velocity.z;
      [newX, newZ] = blockCollision(newX, newZ);
      camera.position.x = newX;
      camera.position.z = newZ;
      camera.position.y += yVel;
      yVel += gravity;
      if(camera.position.y < 1.6){
        camera.position.y = 1.6;
        yVel = 0;
        onGround = true;
      }
      if(doorOpen && doorAnim < 1) doorAnim += 0.05;
      if(!doorOpen && doorAnim > 0) doorAnim -= 0.05;
      doorGroup.rotation.y = -Math.PI/2 * doorAnim;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // === HANDLE RESIZE ===
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
